import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from cross_lib import ox, pmx
import os

# set work dir to current file
os.chdir(os.path.dirname(os.path.abspath(__file__)))

data = pd.read_csv("data/cities.csv", header=None).transpose()
data.columns = ['x', 'y']
cities = np.array(data)

def compute_distance_matrix(cities):
    n = len(cities)
    dist_matrix = np.zeros((n, n))
    for i in range(n):
        for j in range(n):
            dist_matrix[i, j] = np.linalg.norm(cities[i] - cities[j])
    return dist_matrix

distance_matrix = compute_distance_matrix(cities)

def distance(seqs, dist_matrix):
    assert seqs.dtype == np.int32, "The sequence should be a numpy array of int32"
    dist = np.zeros(seqs.shape[0])
    for i in range(seqs.shape[0]):
        seq = seqs[i]
        d = 0.0
        for j in range(len(seq) - 1):
            d += dist_matrix[seq[j], seq[j + 1]]  # 直接查距离方阵
        dist[i] = d
    return dist

def norm_path(path: np.ndarray):
    """
    This function is used to check if a path is equivalent to its reverse or cyclic permutation.

    1. Check the first city and permute to equal path.
    2. Check the second city number and permute to equal path.
    :param path:
    :return:
    """
    assert path.ndim == 1, "The path should be a 1D array"
    assert 0 in path, "The path should start from the first city (0)"  # check if the path starts from the first city
    path = path.copy()
    # Find index of city 0
    start_idx = np.where(path == 0)[0][0]
    # Rotate to start from city 0
    path = np.roll(path, -start_idx)

    # Choose direction (smaller second city)
    if path[1] > path[-1]:
        path[1:] = path[1:][::-1]
    return path

def normal_mutation(individual, rate):
    """
    This function is used to mutate the sequence by swapping two cities.

    Implemented by me firstly and fixed as normal mutation function
    :param individual:
    :param rate:
    :return:
    """
    if np.random.rand() < rate:
        i,j = np.random.choice(len(individual), size=2, replace=False)
        individual[j], individual[i] = individual[i], individual[j]   # swap two random elements
    individual = norm_path(individual)  # make sure the path is valid
    return individual

def adaptive_mutation(individual, mutation_rate):
    """
    Adaptive mutation that decreases over time and uses different strategies

    This function is generated by ChatGPT for optimizing the mutation process,
        and exploiting

    It is tested that using adaptive mutation can improve the performance greatly

    :param individual:
    :param mutation_rate:
    """
    if np.random.random() < mutation_rate:
        strategy = np.random.choice(['swap', 'insert', 'reverse'])

        if strategy == 'swap':
            # Swap two random cities
            i, j = np.random.choice(len(individual), 2, replace=False)
            individual[i], individual[j] = individual[j], individual[i]

        elif strategy == 'insert':
            # Remove a city and insert it elsewhere
            i = np.random.randint(len(individual))
            j = np.random.randint(len(individual))
            city = individual[i]
            individual = np.delete(individual, i)
            individual = np.insert(individual, j, city)

        elif strategy == 'reverse':
            # Reverse a segment
            i, j = sorted(np.random.choice(len(individual), 2, replace=False))
            individual[i:j + 1] = individual[i:j + 1][::-1]

    return individual

def cross(parent_genes,
          child_number,
          mutation_rate=0.1,
          algorithm='PMX',
          mutation_algorithm='normal'):
    """
    In The example MATLAB code, the crossover method is simple Order Crossover (OX).
    Here, we introduce the partial Mapped Crossover (PMX) method.

    :param parent_genes:
    :param child_number:
    :param mutation_rate: the rate of mutation
    :param algorithm: 'PMX' or 'OX'
    :param mutation_algorithm: 'normal' or 'adaptive'
    :return:
    """
    assert child_number % 2 == 0, "The number of children should be even"
    n, l = parent_genes.shape   # number of parents

    children = []
    for _ in range(child_number // 2):
        p1_idx, p2_idx = np.random.choice(n, size=2, replace=False)
        p1, p2 = parent_genes[p1_idx].copy(), parent_genes[p2_idx].copy()

        if algorithm == 'PMX':
            child1, child2 = pmx(p1, p2)
        elif algorithm == 'OX':
            child1, child2 = ox(p1, p2)
        else:
            raise NotImplementedError

        children.append(norm_path(child1))
        children.append(norm_path(child2))

    new_genes = np.vstack(children)

    # ----- mutation -----
    n, l = new_genes.shape
    for i in range(n):
        if mutation_algorithm == 'normal':
            new_genes[i,:] = normal_mutation(new_genes[i, :], mutation_rate)
        elif mutation_algorithm == 'adaptive':
            new_genes[i, :] = adaptive_mutation(new_genes[i,:], mutation_rate)
        else:
            raise NotImplementedError

        new_genes[i,:] = norm_path(new_genes[i,:])
    new_genes = np.vstack([parent_genes, new_genes])
    return new_genes

def generate_vaccines(path_len, n_immune=5):
    """
    This function is used to generate unique vaccine pairs (city swap positions)
    :param path_len: the length of the path
    :param n_immune: the number of vaccines to generate
    :return:
    """
    vaccines = []
    while len(vaccines) < n_immune:
        # sample a vaccine
        new_vaccine = tuple(sorted(np.random.choice(path_len, size=2, replace=False)))
        if new_vaccine not in vaccines:
            vaccines.append(new_vaccine)
    return np.array(vaccines)

def apply_vaccine(seq, vaccine):
    """Apply vaccine (swap two cities) to a sequence"""
    new_seq = seq.copy()
    m, n = vaccine
    new_seq[m], new_seq[n] = new_seq[n], new_seq[m]
    return new_seq

def immune_process(seqs, n_immune=5, elitism_rate = 0.2):
    """
    The immune system for TSP

    We apply the following thought for better immune system :
    - sample for `n_immune` types of vaccines
    - firstly split the group into elitism and non-elitism group
    - for elitism group, we only apply the vaccine that most suit for the individual
    - for non-elitism group, we apply the vaccine that most suit for this group

    :param seqs:
    :param n_immune:
    :param elitism_rate:
    :return:
    """
    nums, seq_len = seqs.shape   # s : number of individuals, l : length of the path
    vaccines = generate_vaccines(seq_len, n_immune)  # generate vaccine

    # we sample for 5 types of vaccines to test on the population
    d0 = distance(seqs, distance_matrix)
    elite_num  = int(nums * elitism_rate)
    top_layer = np.argsort(d0)[:elite_num]  # select the top individuals (minimum distance)
    non_top_layer = np.delete(np.arange(nums), top_layer)  # select the non-top individuals from the population
    
    # --- Elite Layer vaccination ---
    for idx in top_layer:
        vacc_dist = []
        elite_seqs = seqs[idx, :].copy()   # make a copy of the individual
        for vaccine in vaccines:
            new_seq = apply_vaccine(elite_seqs, vaccine)  # apply the vaccine to the individual
            d_new = distance(new_seq.reshape(1, -1), distance_matrix)[0]  # calculate the distance
            vacc_dist.append(d_new)

        best_vaccine_idx = np.argmin(vacc_dist)  # find the best vaccine idx
        if vacc_dist[best_vaccine_idx] < d0[idx]:  # best vaccine is good for this individual
            # apply the vaccine to the individual
            seqs[idx,:] =  apply_vaccine(seqs[idx,:], vaccines[best_vaccine_idx])
    
    #  --- Non-Elite Layer vaccination ---
    if len(non_top_layer) > 0:  # if there are non-top individuals
        vacc_dist = []
        for vaccine in vaccines:
            m, n = vaccine
            group_copy = seqs[non_top_layer].copy()
            group_copy[:, m], group_copy[:, n] = group_copy[:, n], group_copy[:, m]
            avg_dist = np.mean(distance(group_copy, distance_matrix))
            vacc_dist.append(avg_dist)     # calculate the mean distance of the non-top  group
        
        best_vaccine_idx = np.argmin(vacc_dist)  # find the best vaccine idx
        # apply the best vaccine to the non-top group
        current_avg_dist = np.mean(d0[non_top_layer])
        if np.min(vacc_dist) < current_avg_dist:
            m, n = vaccines[best_vaccine_idx]
            # vaccine to the group
            seqs[non_top_layer, m], seqs[non_top_layer, n] = seqs[non_top_layer, n], seqs[non_top_layer, m]
    return seqs

def tsp(cities: np.ndarray,
        n_population = 300,
        n_generations = 100,
        mutate_rate = 0.25,
        elitism_rate = 0.5,
        use_immune = False,
        n_immune = 5,
        immune_elite_rate = 0.2,
        cross_algorithm='PMX',
        mutation_algorithm='adaptive') :
    """
    Traveling Salesman Problem (TSP) using GA (Genetic Algorithm)
    :param cities:
    :param n_population:
    :param n_generations:
    :param mutate_rate:
    :param elitism_rate:
    :param use_immune:
    :param n_immune: see immune_process function for details
    :param immune_elite_rate: see immune_process function for details
    :param cross_algorithm: see cross function for details
    :param mutation_algorithm: see cross function for details
    :return:
    """

    # initialize the population
    seqs = np.vstack([np.random.permutation(len(cities))
                      for _ in range(n_population)]).astype(np.int32)
    seqs = np.vstack([norm_path(seqs[i, :]) for i in range(n_population)])
    d = distance(seqs, distance_matrix)
    min_dist = 1e10
    best_seq = None

    min_dist_arr = []
    avg_dist_arr = []
    # use GA algorithm to optimize the TSP problem
    for epoch in range (n_generations):
        """
        we use max(d) - d as the fitness function to make it minimization
        The higher the fitness, the higher probability of the individual 
            being selected as the parent of the next generation.
        """
        fitness = (np.max(d) - d) / (np.max(d) - np.min(d) + 1e-10)   # normalize the fitness to [0,1]
        prob = fitness / np.sum(fitness)  # not plus 1e-10 for sum prob to be 1
        # select the parents using roulette wheel selection

        # only keep the best individuals for the next generation
        n_parents = int(n_population * elitism_rate)   # number of parents to keep
        parents = np.argsort(prob)[-n_parents:]   # select the top n_parents individuals

        # generate children using crossover
        parent_genes = seqs[parents,:]
        child_number = n_population - len(parents)

        seqs = cross(parent_genes,
                     child_number,
                     mutation_rate=mutate_rate,
                     algorithm=cross_algorithm, # use PMX crossover by default
                     mutation_algorithm=mutation_algorithm)

        # use immune system to avoid getting stuck in local optima
        if use_immune:
            seqs = immune_process(seqs, n_immune, immune_elite_rate)

        d = distance(seqs, distance_matrix)   # update the distances of the new population
        ### evaluate process ###
        best_dist = np.min(d)
        avg_dist  = np.mean(d)

        if best_dist < min_dist:
            min_dist = best_dist
            best_seq = seqs[np.argmin(d)]
            draw_path(cities, best_seq, title="TSP Tour - Epoch: " + str(epoch))

        min_dist_arr.append(min_dist)
        avg_dist_arr.append(avg_dist)
        # note : high mutation rate can be harmful for convergence so we not use it.
        print("Epoch: ", epoch, " Best distance in group: ",
              best_dist, "Minimum distance: " , min_dist)
    print("Minimum distance in group: ", np.min(d))
    # plot the convergence image
    draw_convergence(min_dist_arr, avg_dist_arr)
    return best_seq

def draw_path(cities, path, title="TSP Tour"):
    """
    Plot the path of the TSP tour.

    Generated by ChatGPT
    :param cities: coordinates (n,2)
    :param path: ordered city sequence
    :param title:
    """
    plt.figure(figsize=(8,6))
    # path, closing the tour
    tour = np.append(path, path[0])
    plt.plot(cities[tour, 0], cities[tour, 1], '-o', color='steelblue', markersize=4, linewidth=1.5)

    # highlight starting city
    plt.plot(cities[path[0], 0], cities[path[0], 1], 'ro', markersize=8)

    plt.title(title, fontsize=14)
    plt.xlabel("X")
    plt.ylabel("Y")
    plt.grid(alpha=0.3)
    plt.tight_layout()
    plt.show()


def draw_convergence(history_min_dist, history_avg_dist, title="Convergence Curve"):
    """
    Plot the convergence curve of the TSP optimization process.

    Args:
        history_min_dist (list): List of minimum distances per generation.
        history_avg_dist (list): List of average distances per generation.
        title (str): Title of the plot.

    Generated by ChatGPT
    """
    plt.figure(figsize=(10, 6))
    generations = range(len(history_min_dist))

    # Plot minimum and average distance
    plt.plot(generations, history_min_dist, label="Best Distance", color="steelblue", linewidth=2)
    plt.plot(generations, history_avg_dist, label="Average Distance", color="orange", linestyle="--", linewidth=2)

    plt.xlabel("Generation")
    plt.ylabel("Distance")
    plt.title(title, fontsize=14)
    plt.grid(alpha=0.3)
    plt.legend()
    plt.tight_layout()
    plt.show()

def main():
    best_seq = tsp(cities,
                   n_population=700,
                   n_generations=1000,
                   mutate_rate=0.2,
                   elitism_rate=0.4,
                   use_immune=True,
                   n_immune=10,
                   immune_elite_rate=0.15,  # use first 15% as top layer
                   cross_algorithm='PMX',
                   mutation_algorithm='adaptive'
                   )

    print("Best sequence: ", best_seq)
    draw_path(cities, best_seq, title="TSP Tour - GA optimized result")   # plot the best sequence

if __name__ == "__main__":
    main()

def test_pmx():
    num = 200
    p1 = np.random.permutation(np.arange(num))
    p2 = np.random.permutation(np.arange(num))
    res = cross(np.vstack([p1, p2]), 2)
    assert np.all(sorted(res[2]) == np.arange(len(p1)))
    assert np.all(sorted(res[3]) == np.arange(len(p2)))

def test_immune_process():
    num = 20  # use 20 cities for test
    l = 30    # length of the path
    seqs = np.vstack([np.random.permutation(l) for _ in range(num)]).astype(np.int32)
    d = distance(seqs, distance_matrix)
    seqs = immune_process(seqs, n_immune=5, elitism_rate=0.2)
    d2 = distance(seqs, distance_matrix)
    print("Distance before immune process: ", d)
    print("Distance after immune process: ", d2)

    assert(np.min(d2) <= np.min(d))
