import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

def pmx(p1, p2):
    # select the random crossover points
    l = len(p1)
    cp1, cp2 = np.sort(np.random.choice(l, size=2, replace=False))

    # initialize children (since we start from 0, we initialize -1 for unselected cities)
    child1 = np.zeros(l, dtype=np.int32) - 1
    child2 = np.zeros(l, dtype=np.int32) - 1

    child1[cp1:cp2] = p2[cp1:cp2]
    child2[cp1:cp2] = p1[cp1:cp2]

    # create map1 from p1 to p2
    map1 = {}  # map from p1 to child1
    p1_ = p1[cp1:cp2]
    p2_ = p2[cp1:cp2]
    for a, b in zip(p1_, p2_):
        # we not map a non-exist element to an existing element, so continue
        #        search for non-exist mapping element in p2
        if a not in p2_:
            while b in p1_:
                b = p2_[np.where(p1_ == b)[0][0]]
            map1[a] = b  # map a to b in child1
    map2 = {b: a for a, b in map1.items()}  # reverse map

    for i in np.concatenate([np.array(range(cp1)), np.array(range(cp2, l))]).astype(np.int32):
        child1[i] = p1[i] if p1[i] not in child1 else map2[p1[i]]
        child2[i] = p2[i] if p2[i] not in child2 else map1[p2[i]]

    return child1, child2

def ox(parent1, parent2):
    """
    Order Crossover (OX) - may be more reliable than PMX for TSP

    This part of code is generated by CHATGPT for comparing purposes only.
    """
    size = len(parent1)

    # Choose two random crossover points
    start, end = sorted(np.random.choice(size, 2, replace=False))

    # Create children
    child1 = np.full(size, -1)
    child2 = np.full(size, -1)

    # Copy segments from parents
    child1[start:end] = parent1[start:end]
    child2[start:end] = parent2[start:end]

    # Fill remaining positions
    def fill_child(child, other_parent):
        remaining = [x for x in other_parent if x not in child]
        j = 0
        for i in range(size):
            if child[i] == -1:
                child[i] = remaining[j]
                j += 1
        return child

    child1 = fill_child(child1, parent2)
    child2 = fill_child(child2, parent1)

    return child1.astype(np.int32), child2.astype(np.int32)



